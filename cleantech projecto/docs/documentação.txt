CleanTech — Documentação Completa

Versão da documentação: 1.0
Esta documentação descreve como instalar, configurar, testar e operar todo o projecto CleanTech (Android app, Backend Node.js, Database scripts, Web Dashboard). Inclui referência da API, instruções para M-Pesa, docker, seed de dados, troubleshooting e notas de segurança.


---

Índice

1. Visão Geral / Arquitetura
2. Conteúdo do repositório e caminhos importantes
3. Pré-requisitos
4. Configuração de ambiente (.env)
5. Como rodar — Backend (local / docker)
6. Banco de dados — seed, índices, migração
7. API — referência (endpoints)
8. Fluxos principais (sequência)
9. Integração M-Pesa — guia resumido
10. Web Dashboard — instalação e uso
11. Android App — instruções essenciais
12. DevOps / Deploy (produção) — checklist básico
13. Debug & Troubleshooting (erros comuns)
14. Segurança e boas práticas
15. Postman collection e testes manuais
16. Documentos adicionais / próximos passos
17. Licença e créditos




---

VISÃO GERAL / ARQUITETURA

O projecto CleanTech é composto por 3 blocos principais:

Mobile (Android) — app Kotlin (MapLibre, Socket.IO, Retrofit, FCM). Regista cliente/recolhedor, cria pedidos, inicia pagamento M-Pesa via backend.
Caminho: app/ (fornecido anteriormente).

Backend (Node.js + Express + MongoDB + Socket.IO) — autenticação JWT, endpoints REST, integração M-Pesa, emite eventos em tempo real (socket) para dashboard e apps.
Caminho: backend/

Web Dashboard (Next.js + Leaflet + Socket.IO) — painel admin para visualizar/atribuir pedidos, ver recolhedores no mapa e acompanhar pagamentos.
Caminho: web-dashboard/


Comunicação:

Android & Dashboard ↔ Backend: HTTPS REST + WebSocket (Socket.IO).

Pagamentos: Backend ⇄ Provedor M-Pesa (STK/C2B) com callback público para confirmar pagamentos.

Banco de dados: MongoDB (Atlas ou local).



---

CONTEÚDO DO REPOSITÓRIO E CAMINHOS IMPORTANTES

Resumo dos artefactos que foram entregues (paths já listados nos passos anteriores):

Backend

backend/
├─ server.js
├─ package.json
├─ .env.example
├─ docker-compose.yml
├─ config/db.js
├─ socket/index.js
├─ models/
│  ├─ User.js
│  ├─ Order.js
│  └─ Transaction.js
├─ routes/
│  ├─ auth.js
│  ├─ orders.js
│  └─ payments.js
├─ controllers/
├─ services/mpesaService.js
├─ utils/calcPrice.js
└─ database/
   ├─ seed.js
   ├─ create_indexes.js
   └─ migrate_add_location.js

Web Dashboard

web-dashboard/
├─ package.json
├─ pages/
├─ components/
├─ lib/
├─ styles/
└─ .env.local.example

Android app

app/
├─ build.gradle
├─ src/main/
   ├─ java/com/cleantech/app/...
   └─ res/...

Postman

backend/postman/CleanTech-API.postman_collection.json


---

PRÉ-REQUISITOS

Node.js v18+ (recomendado).

npm (ou yarn).

Docker & docker-compose (opcional, recomendado para testes locais).

MongoDB Atlas ou Docker Mongo local.

(Se usar FCM) Conta Firebase + google-services.json (Android).

Credenciais M-Pesa (Vodacom / Safaricom) para produção — em sandbox use MPESA_PROVIDER=simulator.



---

CONFIGURAÇÃO DE AMBIENTE (.env)

Crie backend/.env (baseado em .env.example) com:

PORT=4000
ENV=development
MONGODB_URI=<sua_uri_mongodb>
JWT_SECRET=<segredo_jwt_forte>
JWT_EXPIRY=7d

# M-Pesa
MPESA_PROVIDER=simulator        # vodacom_mz | safaricom | simulator
MPESA_API_URL=https://api.example
MPESA_CONSUMER_KEY=...
MPESA_CONSUMER_SECRET=...
MPESA_SERVICE_PROVIDER_CODE=...
MPESA_SHORTCODE=...
MPESA_PASSKEY=...
MPESA_CALLBACK_URL=https://yourdomain.com/api/payments/mpesa/callback

FRONTEND_ORIGIN=http://localhost:3000

Notas:

Nunca comitar o .env.

No web-dashboard crie .env.local:


NEXT_PUBLIC_API_URL=http://localhost:4000/api
NEXT_PUBLIC_SOCKET_URL=http://localhost:4000


---

COMO RODAR — BACKEND (LOCAL / DOCKER)

1) Rodar via Docker (recomendado para dev)

1. Na pasta backend/ garanta que docker-compose.yml está presente.


2. Executar:



docker-compose up --build

3. Isso iniciará:

MongoDB em mongo:27017

Backend em :4000 com MPESA_PROVIDER=simulator (por default no compose).



4. Verificar health:



GET http://localhost:4000/api/health

2) Rodar localmente (sem Docker)

cd backend
npm install
cp .env.example .env         # editar .env com MONGODB_URI etc
npm run dev                  # usa nodemon (dev)
# ou
npm start


---

BANCO DE DADOS — SEED, ÍNDICES, MIGRAÇÃO

Seed (gerar dados de teste)

Executar (a partir de backend/):

node database/seed.js

O seed cria: Admin, Cliente, 2 Recolhedores, 3 Ordens, 2 Transações de exemplo.

Criar índices

node database/create_indexes.js

Cria:

users.phone (unique)

orders.status, createdAt

orders.location 2dsphere (se location existir)

transactions índices em mpesa ids e status


Migrar lat/lng para GeoJSON location

Se seus documentos têm lat e lng mas não location:

node database/migrate_add_location.js
node database/create_indexes.js   # recriar índice geoespacial


---

API — REFERÊNCIA (ENDPOINTS ESSENCIAIS)

> Base URL: https://<backend>/api (local: http://localhost:4000/api)



Autenticação

POST /auth/register

Body: { name, phone, password, role? }

Returns: { token, user }

No OTP (conforme pedido) — número guardado sem verificação.


POST /auth/login

Body: { phone, password }

Returns: { token, user }



Pedidos (orders)

POST /orders (auth)

Body: { type, quantityKg, address, lat, lng, distanceKm }

Server calcula price via utils/calcPrice.js. Retorna Order criado e emite new_order via socket.


GET /orders/client/:clientId (auth)

Retorna pedidos do cliente.


(Recomendado para dashboard) GET /orders/admin — listar todos (implementei opção no dashboard; se ausente, UI funciona em compat mode).

POST /orders/:id/assign (admin) — endpoint sugerido (atribuir collector). Body: { collectorId }

POST /orders/:id/complete — endpoint sugerido (marcar concluído)


Pagamentos (M-Pesa)

POST /payments/mpesa/init (auth)

Body: { orderId?, amount, phone }

Cria Transaction pendente e chama services/mpesaService.initMpesaPayment. Retorna trxId e mpesa response.


POST /payments/mpesa/callback (public)

Recebe callback do provedor M-Pesa (STK/C2B). O controller valida e atualiza Transaction. Emite payment_confirmed via socket.



Outros (sugestões)

GET /collectors — listar recolhedores com localização. (Dashboard usa)

GET /users — listar usuários (admin)

GET /payments — listar transações

GET /reports — listar denúncias



---

FLUXOS PRINCIPAIS (SEQUENCE)

Criar pedido → Pagamento → Confirmação → Notificação

1. Cliente cria pedido (POST /orders) → backend calcula preço → grava Order com status: pending → emite socket new_order.


2. Cliente inicia pagamento (POST /payments/mpesa/init) → backend cria Transaction status pending e invoca Provedor M-Pesa (STK/C2B).


3. Usuário confirma pagamento no celular (segundo o flow da operadora) → Provedor chama POST /payments/mpesa/callback.


4. Backend valida callback → atualiza Transaction.status = paid → se orderId presente, backend pode atualizar Order e emitir socket payment_confirmed → app/dashboard recebem e atualizam UI.




---

INTEGRAÇÃO M-PESA — GUIA RESUMIDO (IMPORTANTE)

Arquivo principal: backend/services/mpesaService.js — suporta MPESA_PROVIDER=simulator, vodacom_mz e safaricom (Daraja).

Sandbox vs Produção:

Em sandbox → use MPESA_PROVIDER=simulator (ou sandbox endpoints e credenciais do provedor).

Em produção → obter credenciais oficiais, endpoints e URLs callback do provedor (Vodacom Moçambique / Safaricom).


Callback:

Callback deve ser público HTTPS com certificado válido e configurado no painel do provedor.

Verifique formato do JSON que a operadora envia; mpesaService.validateMpesaCallback tenta normalizar STK Push (Daraja), ajusta conforme precisa.


Testes locais:

Use MPESA_PROVIDER=simulator para evitar chamadas externas.

Simule callback com Postman (ex.: use o body de exemplo em postman/CleanTech-API.postman_collection.json).




---

WEB DASHBOARD — INSTALAÇÃO E USO (RESUMO)

1. Entrar em web-dashboard/.


2. cp .env.local.example .env.local e ajustar valores.


3. npm install


4. npm run dev → acessar http://localhost:3000.


5. Faz login com usuário do seed (ex.: +258840000002 / client123), ou cria usuário via backend.



Observações:

Dashboard está tolerante a endpoints ausentes (compat mode). Quando endpoints admin são adicionados ao backend, UI ativa ações (atribuir, completar etc).

Mapas usam OpenStreetMap (sem custo).



---

ANDROID APP — INSTRUÇÕES ESSENCIAIS

Abra Android Studio, importe o app/ folder como projeto Gradle.

Atualize ApiClient.BASE_URL em app/src/main/java/.../network/ApiClient.kt para o seu backend (ex.: http://10.0.2.2:4000/api se usar em emulador).

Adicione google-services.json em app/ se quiser FCM (opcional).

Permissões: localização (runtime).

Build & Run num dispositivo real (recomendo para testar M-Pesa flows). Emulador pode ter limitações em pagamentos STK e integração com telephony.



---

DEVOPS / DEPLOY (PRODUÇÃO) — CHECKLIST RÁPIDO

Use HTTPS (Let's Encrypt / managed certs).

Configurar variáveis de ambiente seguras (JWT_SECRET forte).

Usar MongoDB Atlas (production tier).

Escalar Socket.IO com Redis adapter se usar múltiplas instâncias.

Proteja endpoints de callback (IP allowlist / verificações de assinatura se provedor suportar).

Habilitar logs estruturados e monitoramento (Sentry / LogDNA).

Faça backup do banco regularmente.



---

DEBUG & TROUBLESHOOTING (ERROS COMUNS)

1. MONGODB_URI connection error

Verifique a string de conexão, firewall, rede/VPC. Teste com mongo client ou Compass.

Em docker compose: certifique-se que MONGODB_URI para backend aponta para mongodb://mongo:27017/cleantech (ou altere depends_on).


2. Token JWT inválido / 401

Certifique-se de que JWT_SECRET no .env do servidor seja igual ao usado quando o token foi emitido.

No cliente, verifique header Authorization: Bearer <token>.


3. Socket.IO não conecta

Verifique CORS: initSocket(server, { cors: { origin: process.env.FRONTEND_ORIGIN } }).

No cliente use o mesmo protocolo (http/https) e porta corretos.

Logs: server console imprime quando socket conectado.


4. MPesa init timeout / 500

Verifique credenciais (consumer key/secret), URL do provedor e formato do payload.

Em dev use MPESA_PROVIDER=simulator.


5. Índice unique phone falha na criação

Há registros duplicados. Liste os telefones duplicados, corrija e tente recriar índice.



---

POSTMAN COLLECTION & TESTES MANUAIS

Importar: backend/postman/CleanTech-API.postman_collection.json.

Variáveis úteis:

baseUrl = http://localhost:4000

token = JWT pós-login

orderId = id retornado em create order



Fluxo de teste (Postman):

1. POST /api/auth/register (seed já fornece contas)


2. POST /api/auth/login → pegar token


3. POST /api/orders (Authorization header)


4. POST /api/payments/mpesa/init (Authorization)


5. POST /api/payments/mpesa/callback → simular confirmação




---

DOCUMENTOS ADICIONAIS / PRÓXIMOS PASSOS SUGERIDOS

Gerar endpoints admin (se deseja que eu os adicione eu já preparei patches).

Implementar tracking de localização de recolhedores (endpoint + socket position_update) — útil para dispatch em tempo real.

Painel de análise (relatórios mensais), integração com Map tiles own host (MapTiler/tileserver) se tráfego aumentar.

Auditoria de segurança (API keys, validações).



---

README (sugestão de ficheiro README.md para raiz do repositório)

Crie um README.md com um resumo, e inclua um quickstart (docker-compose) + pointers para docs (este ficheiro).

Exemplo de conteúdo (síntese):

# CleanTech

## Quickstart (dev)
1. Backend:
   - `cd backend`
   - `cp .env.example .env` (edite)
   - `docker-compose up --build`  # or `npm install && npm run dev`

2. Seed DB (opcional):
   - `node database/seed.js`

3. Web dashboard:
   - `cd web-dashboard`
   - `cp .env.local.example .env.local`
   - `npm install && npm run dev`

4. Android:
   - Abra `app/` em Android Studio, ajuste `ApiClient.BASE_URL` e rode no dispositivo.

## Docs
- API reference, M-Pesa integration and troubleshooting: see `/docs` or main project README.


---

LICENÇA E CRÉDITOS

Código entregue sob licença MIT (sinta-se livre para adaptar).

Créditos: estruturado pelo assistente (templates e integrações padrão).



---

Se desejar, eu:

A. Gero automaticamente o README.md e arquivos docs/ (separando API.md, MPESA.md, DEPLOY.md) em formato prontos para colar no repositório;

B. Adiciono endpoints admin do backend (GET /orders/admin, /collectors, /users, /payments, /reports e POST /orders/:id/assign /complete) — já preparei antes e posso colar sem perguntas;

C. Faço um script CI/CD básico (GitHub Actions) para Build + Test + Lint.


Diz qual (A/B/C) queres agora que eu gere e eu adiciono os ficheiros prontos aqui.

